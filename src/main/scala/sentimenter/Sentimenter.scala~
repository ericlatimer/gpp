package sentimenter

import nak.util.ConfusionMatrix
import chalk.lang.eng.PorterStemmer
import chalk.util.SimpleTokenizer

/**
 * An object that sets up the configuration for command-line options using
 * Scallop and returns the options, ready for use.
 *	-c, --cost  <arg>       The cost parameter C. Bigger values means less
 *                          regularization (more fidelity to the training set).
 *                          (default = 1.0)
 *  -d, --detailed          
 *  -e, --eval  <arg>...    The files containing evalualation events.
 *  -x, --extended          Use extended features.
 *  -m, --method  <arg>     The type of solver to use. Possible values: majority,
 *                          lexicon, or any liblinear solver type.
 *                         (default = L2R_LR)
 *  -t, --train  <arg>...   The files containing training events.
 *  -v, --verbose           
 *      --help              Show this message
 *      --version           Show version of this program
 *
 */
object SentimenterOpts {

  import org.rogach.scallop._
  
  def apply(args: Array[String]) = new ScallopConf(args) {
    banner("""
For usage see below:
	     """)
	val cost = opt[String]("cost", short = 'c', descr = "The cost parameter C.")
	val detailed = opt[Boolean]("detailed", short = 'd', descr = "Should output the correctly and incorrectly results please.")
	val eval = opt[String]("eval", short = 'e', descr = "The files containing evalualation events.")
	val extended = opt[Boolean]("extended", short = 'x', descr = "Use extended features.")
	val method = opt[String]("method", short = 'm', descr = "The type of solver to use. Possible values: majority, lexicon, or any liblinear solver type.")
	val train = opt[String]("train", short = 't', descr = "The files containing training events.")
	val verbose = opt[Boolean]("verbose", short = 'v', descr = "Use extended features.")
	val help = opt[Boolean]("help", noshort = true, descr = "Show this message.")
	val version = opt[Boolean]("version", noshort = true, descr = "Show version of this program.")
  }
}

/*
 	@param goldLabels	the set of labels from the gold labeled data
  	@param predictedOutcomes a set of (usually autogenerated) labels for the predicted clusters
  	@param counts the matrix, where each cell is the number of data points that had a given gold label 			and predicted label

	(goldLabels: Seq[String], predictedLabels: Seq[String], items: Seq[String])
*/

/**
 * 
 */
object Sentimenter {

  /**
   * Main
   */
  def main(args: Array[String]) {
	val opts = SentimenterOpts(args)

	//Digest training data
	val trainXML = scala.xml.XML.loadFile(opts.train())
	val allTrainingLabels = (trainXML \\ "item").map { item =>
	  ((item \ "@label").text)
	}
	val allTrainingTweets = (trainXML \\ "content").map{x => x.text}
	val allTrainingPairs = allTrainingLabels.zip(allTrainingTweets)

	//Digest eval data
	val evalXML = scala.xml.XML.loadFile(opts.eval())
	val allEvalLabels = (evalXML \\ "item").map { item =>
	  ((item \ "@label").text)
	}
	val allEvalTweets = (evalXML \\ "content").map{x => x.text}
	val allEvalPairs = allEvalLabels.zip(allEvalTweets)

	allEvalPairs.foreach(println)

	val (labels, counts) = allTrainingLabels.groupBy(x => x).map{pair => (pair._1, pair._2.length)}.unzip
	labels.foreach(println)
	counts.foreach(println)

	//val confusionMatrix = ConfusionMatrix(labels.toIndexedSeq,labels.toIndexedSeq,counts)
  }

}
