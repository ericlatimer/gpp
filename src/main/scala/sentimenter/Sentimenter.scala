package sentimenter

import nak.util.ConfusionMatrix
import chalk.lang.eng.PorterStemmer
import chalk.util.SimpleTokenizer

/**
 * An object that sets up the configuration for command-line options using
 * Scallop and returns the options, ready for use.
 *	-c, --cost  <arg>       The cost parameter C. Bigger values means less
 *                          regularization (more fidelity to the training set).
 *                          (default = 1.0)
 *  -d, --detailed          
 *  -e, --eval  <arg>...    The files containing evalualation events.
 *  -x, --extended          Use extended features.
 *  -m, --method  <arg>     The type of solver to use. Possible values: majority,
 *                          lexicon, or any liblinear solver type.
 *                         (default = L2R_LR)
 *  -t, --train  <arg>...   The files containing training events.
 *  -v, --verbose           
 *      --help              Show this message
 *      --version           Show version of this program
 *
 */
object SentimenterOpts {

  import org.rogach.scallop._
  
  def apply(args: Array[String]) = new ScallopConf(args) {
    banner("""
For usage see below:
	     """)
	val cost = opt[Double]("cost", short = 'c', default=Some(1.0), descr = "The cost parameter C.")
	val detailed = opt[Boolean]("detailed", short = 'd', descr = "Should output the correctly and incorrectly results please.")
	val eval = opt[String]("eval", short = 'e', descr = "The files containing evalualation events.")
	val extended = opt[Boolean]("extended", short = 'x', descr = "Use extended features.")
	val method = opt[String]("method", short = 'm', default=Some("L2R_LR"), descr = "The type of solver to use. Possible values: majority, lexicon, or any liblinear solver type.")
	val train = opt[String]("train", short = 't', descr = "The files containing training events.")
	val verbose = opt[Boolean]("verbose", short = 'v', descr = "Use extended features.")
	val help = opt[Boolean]("help", noshort = true, descr = "Show this message.")
	val version = opt[Boolean]("version", noshort = true, descr = "Show version of this program.")
  }
}

/*
 	@param goldLabels	the set of labels from the gold labeled data
  	@param predictedOutcomes a set of (usually autogenerated) labels for the predicted clusters
  	@param counts the matrix, where each cell is the number of data points that had a given gold label 			and predicted label

	(goldLabels: Seq[String], predictedLabels: Seq[String], items: Seq[String])
*/

/**
 * 
 */
object Sentimenter {

  /**
   * Main
   */
  def main(args: Array[String]) {
	val opts = SentimenterOpts(args)

	if (opts.method() == "majority") {
		Majority(opts.train(), opts.eval())
	} else if (opts.method() == "lexicon") {
		Lexicon(opts.eval())
	} else
		Fancy(opts.train(), opts.eval(), opts.cost())
  }

}